/*******************************************************************
* Social Robot – Thunderstorm Phobia
* Stable DFPlayer + Relays + Pause system
*******************************************************************/

#include <HardwareSerial.h>
#include <DFRobotDFPlayerMini.h>

// ---------- Blauwe uitleg / pauze LEDs ----------
const int blueLeds[4] = {25, 33, 32, 15};

// ---------- Relais ----------
#define RELAY1 13
#define RELAY2 12
#define RELAY3 14
#define RELAY4 27

// ---------- DFPlayer ----------
#define DF_BUSY 26   // LOW = playing

// ---------- Buttons ----------
const int buttonPins[6] = {5, 22, 23, 18, 19, 21}; // 5 levels + stop

// ---------- Level configuration ----------
struct LevelConfig {
  int tracks[10];
  int trackCount;
  int relays[4];       // which relays pulse
  int flashTime;       // ms
  int volume;
  int uitlegTrack;
};

LevelConfig levels[5] = {
  {{7,8,9,10,11,12},    6, {0,0,0,0}, 200,  5, 2},
  {{13,14,15,16},      4, {1,0,0,0}, 200, 10, 3},
  {{17,18,19,20,21,22},6, {1,0,0,1}, 200, 14, 4},
  {{23,24,25,26},      4, {1,1,1,1}, 200, 18, 5},
  {{26,27,28,29,30},   5, {1,1,1,1}, 200, 22, 6}
};

// ---------- States ----------
enum SystemState { IDLE, WAIT_CONFIRM, PLAYING, PAUSED };
SystemState systemState = IDLE;

// ---------- Globals ----------
HardwareSerial mySerial(2);
DFRobotDFPlayerMini myDFPlayer;

int currentLevel = -1;
int pendingLevel = -1;
int lastTrackPlayed = -1;
bool trackPlaying = false;

// ---------- Utility ----------
void setAllRelays(bool off) {
  digitalWrite(RELAY1, off);
  digitalWrite(RELAY2, off);
  digitalWrite(RELAY3, off);
  digitalWrite(RELAY4, off);
}

void setBlueLeds(bool on) {
  for (int i = 0; i < 4; i++) {
    digitalWrite(blueLeds[i], on ? HIGH : LOW);
  }
}

void waitUntilAudioFinished() {
  delay(300);
  while (digitalRead(DF_BUSY) == LOW) {
    delay(100);
  }
}

// ---------- Relays pulse ----------
void pulseRelays(int level) {
  for (int i = 0; i < 4; i++) {
    if (levels[level-1].relays[i]) {
      int pin = (i==0?RELAY1:(i==1?RELAY2:(i==2?RELAY3:RELAY4)));
      digitalWrite(pin, LOW);
    }
  }
  delay(levels[level-1].flashTime);
  setAllRelays(HIGH);
}

// ---------- Audio ----------
void playOneRandomTrack(int level) {
  int count = levels[level-1].trackCount;
  int index;

  do {
    index = random(0, count);
  } while (levels[level-1].tracks[index] == lastTrackPlayed);

  lastTrackPlayed = levels[level-1].tracks[index];

  pulseRelays(level);

  myDFPlayer.play(lastTrackPlayed);
  trackPlaying = true;
  delay(300); // allow BUSY to go LOW
}

// ---------- Stop ----------
void stopAll() {
  setAllRelays(HIGH);
  setBlueLeds(false);
  myDFPlayer.stop();

  currentLevel = -1;
  pendingLevel = -1;
  trackPlaying = false;
  systemState = IDLE;
}

// ---------- Pause ----------
void playPauseAudio() {
  setBlueLeds(true);
  myDFPlayer.play(99);   // ⬅️ pauze-audio (zelf kiezen)
  waitUntilAudioFinished();
  setBlueLeds(false);
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);

  pinMode(RELAY1, OUTPUT);
  pinMode(RELAY2, OUTPUT);
  pinMode(RELAY3, OUTPUT);
  pinMode(RELAY4, OUTPUT);
  setAllRelays(HIGH);

  for (int i = 0; i < 4; i++) {
    pinMode(blueLeds[i], OUTPUT);
    digitalWrite(blueLeds[i], LOW);
  }

  pinMode(DF_BUSY, INPUT);

  for (int i = 0; i < 6; i++) {
    pinMode(buttonPins[i], INPUT_PULLUP);
  }

  mySerial.begin(9600, SERIAL_8N1, 16, 17);
  if (!myDFPlayer.begin(mySerial)) {
    while (true);
  }

  randomSeed(analogRead(34));
  myDFPlayer.volume(12);

  // Startup audio
  setBlueLeds(true);
  myDFPlayer.play(1);
  waitUntilAudioFinished();
  setBlueLeds(false);
}

// ---------- Loop ----------
void loop() {

  // ---------- Buttons ----------
  for (int i = 0; i < 6; i++) {
    if (digitalRead(buttonPins[i]) == LOW) {
      delay(200);

      // STOP
      if (i == 5) {
        stopAll();
        return;
      }

      // PAUSE / RESUME
      if (systemState == PLAYING) {
        systemState = PAUSED;
        myDFPlayer.stop();
        trackPlaying = false;
        playPauseAudio();
        return;
      }

      if (systemState == PAUSED) {
        systemState = PLAYING;
        return;
      }

      int selectedLevel = i + 1;

      // FIRST CLICK → explanation
      if (systemState == IDLE) {
        pendingLevel = selectedLevel;
        systemState = WAIT_CONFIRM;

        setBlueLeds(true);
        myDFPlayer.play(levels[pendingLevel-1].uitlegTrack);
        waitUntilAudioFinished();
        setBlueLeds(false);
        return;
      }

      // SECOND CLICK → start level
      if (systemState == WAIT_CONFIRM && pendingLevel == selectedLevel) {
        currentLevel = selectedLevel;
        pendingLevel = -1;
        systemState = PLAYING;

        myDFPlayer.volume(levels[currentLevel-1].volume);
        trackPlaying = false;
        return;
      }
    }
  }

  // ---------- Playback state ----------
  if (systemState == PLAYING) {

    if (trackPlaying && digitalRead(DF_BUSY) == LOW) {
      return; // still playing
    }

    if (trackPlaying && digitalRead(DF_BUSY) == HIGH) {
      trackPlaying = false;
      delay(300);
    }

    if (!trackPlaying) {
      playOneRandomTrack(currentLevel);
    }
  }
}
